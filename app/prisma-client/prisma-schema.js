module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AccountType {
  id: ID!
  name: String!
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccountTypeConnection {
  pageInfo: PageInfo!
  edges: [AccountTypeEdge]!
  aggregate: AggregateAccountType!
}

input AccountTypeCreateInput {
  id: ID
  name: String!
  users: UserCreateManyWithoutAccount_typeInput
  permissions: PermissionCreateManyInput
}

input AccountTypeCreateOneWithoutUsersInput {
  create: AccountTypeCreateWithoutUsersInput
  connect: AccountTypeWhereUniqueInput
}

input AccountTypeCreateWithoutUsersInput {
  id: ID
  name: String!
  permissions: PermissionCreateManyInput
}

type AccountTypeEdge {
  node: AccountType!
  cursor: String!
}

enum AccountTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AccountTypePreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AccountTypeSubscriptionPayload {
  mutation: MutationType!
  node: AccountType
  updatedFields: [String!]
  previousValues: AccountTypePreviousValues
}

input AccountTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AccountTypeWhereInput
  AND: [AccountTypeSubscriptionWhereInput!]
  OR: [AccountTypeSubscriptionWhereInput!]
  NOT: [AccountTypeSubscriptionWhereInput!]
}

input AccountTypeUpdateInput {
  name: String
  users: UserUpdateManyWithoutAccount_typeInput
  permissions: PermissionUpdateManyInput
}

input AccountTypeUpdateManyMutationInput {
  name: String
}

input AccountTypeUpdateOneRequiredWithoutUsersInput {
  create: AccountTypeCreateWithoutUsersInput
  update: AccountTypeUpdateWithoutUsersDataInput
  upsert: AccountTypeUpsertWithoutUsersInput
  connect: AccountTypeWhereUniqueInput
}

input AccountTypeUpdateWithoutUsersDataInput {
  name: String
  permissions: PermissionUpdateManyInput
}

input AccountTypeUpsertWithoutUsersInput {
  update: AccountTypeUpdateWithoutUsersDataInput!
  create: AccountTypeCreateWithoutUsersInput!
}

input AccountTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  users_every: UserWhereInput
  users_some: UserWhereInput
  users_none: UserWhereInput
  permissions_every: PermissionWhereInput
  permissions_some: PermissionWhereInput
  permissions_none: PermissionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AccountTypeWhereInput!]
  OR: [AccountTypeWhereInput!]
  NOT: [AccountTypeWhereInput!]
}

input AccountTypeWhereUniqueInput {
  id: ID
}

type AggregateAccountType {
  count: Int!
}

type AggregateChatRoom {
  count: Int!
}

type AggregateMessageContent {
  count: Int!
}

type AggregatePermission {
  count: Int!
}

type AggregateSpecialization {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type ChatRoom {
  id: ID!
  recipients(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  content(where: MessageContentWhereInput, orderBy: MessageContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MessageContent!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChatRoomConnection {
  pageInfo: PageInfo!
  edges: [ChatRoomEdge]!
  aggregate: AggregateChatRoom!
}

input ChatRoomCreateInput {
  id: ID
  recipients: UserCreateManyWithoutChatRoomsInput
  content: MessageContentCreateManyWithoutChatRoomInput
}

input ChatRoomCreateManyWithoutRecipientsInput {
  create: [ChatRoomCreateWithoutRecipientsInput!]
  connect: [ChatRoomWhereUniqueInput!]
}

input ChatRoomCreateOneWithoutContentInput {
  create: ChatRoomCreateWithoutContentInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomCreateWithoutContentInput {
  id: ID
  recipients: UserCreateManyWithoutChatRoomsInput
}

input ChatRoomCreateWithoutRecipientsInput {
  id: ID
  content: MessageContentCreateManyWithoutChatRoomInput
}

type ChatRoomEdge {
  node: ChatRoom!
  cursor: String!
}

enum ChatRoomOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ChatRoomPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ChatRoomScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ChatRoomScalarWhereInput!]
  OR: [ChatRoomScalarWhereInput!]
  NOT: [ChatRoomScalarWhereInput!]
}

type ChatRoomSubscriptionPayload {
  mutation: MutationType!
  node: ChatRoom
  updatedFields: [String!]
  previousValues: ChatRoomPreviousValues
}

input ChatRoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatRoomWhereInput
  AND: [ChatRoomSubscriptionWhereInput!]
  OR: [ChatRoomSubscriptionWhereInput!]
  NOT: [ChatRoomSubscriptionWhereInput!]
}

input ChatRoomUpdateInput {
  recipients: UserUpdateManyWithoutChatRoomsInput
  content: MessageContentUpdateManyWithoutChatRoomInput
}

input ChatRoomUpdateManyWithoutRecipientsInput {
  create: [ChatRoomCreateWithoutRecipientsInput!]
  delete: [ChatRoomWhereUniqueInput!]
  connect: [ChatRoomWhereUniqueInput!]
  set: [ChatRoomWhereUniqueInput!]
  disconnect: [ChatRoomWhereUniqueInput!]
  update: [ChatRoomUpdateWithWhereUniqueWithoutRecipientsInput!]
  upsert: [ChatRoomUpsertWithWhereUniqueWithoutRecipientsInput!]
  deleteMany: [ChatRoomScalarWhereInput!]
}

input ChatRoomUpdateOneRequiredWithoutContentInput {
  create: ChatRoomCreateWithoutContentInput
  update: ChatRoomUpdateWithoutContentDataInput
  upsert: ChatRoomUpsertWithoutContentInput
  connect: ChatRoomWhereUniqueInput
}

input ChatRoomUpdateWithoutContentDataInput {
  recipients: UserUpdateManyWithoutChatRoomsInput
}

input ChatRoomUpdateWithoutRecipientsDataInput {
  content: MessageContentUpdateManyWithoutChatRoomInput
}

input ChatRoomUpdateWithWhereUniqueWithoutRecipientsInput {
  where: ChatRoomWhereUniqueInput!
  data: ChatRoomUpdateWithoutRecipientsDataInput!
}

input ChatRoomUpsertWithoutContentInput {
  update: ChatRoomUpdateWithoutContentDataInput!
  create: ChatRoomCreateWithoutContentInput!
}

input ChatRoomUpsertWithWhereUniqueWithoutRecipientsInput {
  where: ChatRoomWhereUniqueInput!
  update: ChatRoomUpdateWithoutRecipientsDataInput!
  create: ChatRoomCreateWithoutRecipientsInput!
}

input ChatRoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  recipients_every: UserWhereInput
  recipients_some: UserWhereInput
  recipients_none: UserWhereInput
  content_every: MessageContentWhereInput
  content_some: MessageContentWhereInput
  content_none: MessageContentWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ChatRoomWhereInput!]
  OR: [ChatRoomWhereInput!]
  NOT: [ChatRoomWhereInput!]
}

input ChatRoomWhereUniqueInput {
  id: ID
}

scalar DateTime

scalar Long

type MessageContent {
  id: ID!
  sender: User!
  text: String!
  chatRoom: ChatRoom!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MessageContentConnection {
  pageInfo: PageInfo!
  edges: [MessageContentEdge]!
  aggregate: AggregateMessageContent!
}

input MessageContentCreateInput {
  id: ID
  sender: UserCreateOneInput!
  text: String!
  chatRoom: ChatRoomCreateOneWithoutContentInput!
}

input MessageContentCreateManyWithoutChatRoomInput {
  create: [MessageContentCreateWithoutChatRoomInput!]
  connect: [MessageContentWhereUniqueInput!]
}

input MessageContentCreateWithoutChatRoomInput {
  id: ID
  sender: UserCreateOneInput!
  text: String!
}

type MessageContentEdge {
  node: MessageContent!
  cursor: String!
}

enum MessageContentOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type MessageContentPreviousValues {
  id: ID!
  text: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input MessageContentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MessageContentScalarWhereInput!]
  OR: [MessageContentScalarWhereInput!]
  NOT: [MessageContentScalarWhereInput!]
}

type MessageContentSubscriptionPayload {
  mutation: MutationType!
  node: MessageContent
  updatedFields: [String!]
  previousValues: MessageContentPreviousValues
}

input MessageContentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageContentWhereInput
  AND: [MessageContentSubscriptionWhereInput!]
  OR: [MessageContentSubscriptionWhereInput!]
  NOT: [MessageContentSubscriptionWhereInput!]
}

input MessageContentUpdateInput {
  sender: UserUpdateOneRequiredInput
  text: String
  chatRoom: ChatRoomUpdateOneRequiredWithoutContentInput
}

input MessageContentUpdateManyDataInput {
  text: String
}

input MessageContentUpdateManyMutationInput {
  text: String
}

input MessageContentUpdateManyWithoutChatRoomInput {
  create: [MessageContentCreateWithoutChatRoomInput!]
  delete: [MessageContentWhereUniqueInput!]
  connect: [MessageContentWhereUniqueInput!]
  set: [MessageContentWhereUniqueInput!]
  disconnect: [MessageContentWhereUniqueInput!]
  update: [MessageContentUpdateWithWhereUniqueWithoutChatRoomInput!]
  upsert: [MessageContentUpsertWithWhereUniqueWithoutChatRoomInput!]
  deleteMany: [MessageContentScalarWhereInput!]
  updateMany: [MessageContentUpdateManyWithWhereNestedInput!]
}

input MessageContentUpdateManyWithWhereNestedInput {
  where: MessageContentScalarWhereInput!
  data: MessageContentUpdateManyDataInput!
}

input MessageContentUpdateWithoutChatRoomDataInput {
  sender: UserUpdateOneRequiredInput
  text: String
}

input MessageContentUpdateWithWhereUniqueWithoutChatRoomInput {
  where: MessageContentWhereUniqueInput!
  data: MessageContentUpdateWithoutChatRoomDataInput!
}

input MessageContentUpsertWithWhereUniqueWithoutChatRoomInput {
  where: MessageContentWhereUniqueInput!
  update: MessageContentUpdateWithoutChatRoomDataInput!
  create: MessageContentCreateWithoutChatRoomInput!
}

input MessageContentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  sender: UserWhereInput
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  chatRoom: ChatRoomWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [MessageContentWhereInput!]
  OR: [MessageContentWhereInput!]
  NOT: [MessageContentWhereInput!]
}

input MessageContentWhereUniqueInput {
  id: ID
}

type Mutation {
  createAccountType(data: AccountTypeCreateInput!): AccountType!
  updateAccountType(data: AccountTypeUpdateInput!, where: AccountTypeWhereUniqueInput!): AccountType
  updateManyAccountTypes(data: AccountTypeUpdateManyMutationInput!, where: AccountTypeWhereInput): BatchPayload!
  upsertAccountType(where: AccountTypeWhereUniqueInput!, create: AccountTypeCreateInput!, update: AccountTypeUpdateInput!): AccountType!
  deleteAccountType(where: AccountTypeWhereUniqueInput!): AccountType
  deleteManyAccountTypes(where: AccountTypeWhereInput): BatchPayload!
  createChatRoom(data: ChatRoomCreateInput!): ChatRoom!
  updateChatRoom(data: ChatRoomUpdateInput!, where: ChatRoomWhereUniqueInput!): ChatRoom
  upsertChatRoom(where: ChatRoomWhereUniqueInput!, create: ChatRoomCreateInput!, update: ChatRoomUpdateInput!): ChatRoom!
  deleteChatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  deleteManyChatRooms(where: ChatRoomWhereInput): BatchPayload!
  createMessageContent(data: MessageContentCreateInput!): MessageContent!
  updateMessageContent(data: MessageContentUpdateInput!, where: MessageContentWhereUniqueInput!): MessageContent
  updateManyMessageContents(data: MessageContentUpdateManyMutationInput!, where: MessageContentWhereInput): BatchPayload!
  upsertMessageContent(where: MessageContentWhereUniqueInput!, create: MessageContentCreateInput!, update: MessageContentUpdateInput!): MessageContent!
  deleteMessageContent(where: MessageContentWhereUniqueInput!): MessageContent
  deleteManyMessageContents(where: MessageContentWhereInput): BatchPayload!
  createPermission(data: PermissionCreateInput!): Permission!
  updatePermission(data: PermissionUpdateInput!, where: PermissionWhereUniqueInput!): Permission
  updateManyPermissions(data: PermissionUpdateManyMutationInput!, where: PermissionWhereInput): BatchPayload!
  upsertPermission(where: PermissionWhereUniqueInput!, create: PermissionCreateInput!, update: PermissionUpdateInput!): Permission!
  deletePermission(where: PermissionWhereUniqueInput!): Permission
  deleteManyPermissions(where: PermissionWhereInput): BatchPayload!
  createSpecialization(data: SpecializationCreateInput!): Specialization!
  updateSpecialization(data: SpecializationUpdateInput!, where: SpecializationWhereUniqueInput!): Specialization
  updateManySpecializations(data: SpecializationUpdateManyMutationInput!, where: SpecializationWhereInput): BatchPayload!
  upsertSpecialization(where: SpecializationWhereUniqueInput!, create: SpecializationCreateInput!, update: SpecializationUpdateInput!): Specialization!
  deleteSpecialization(where: SpecializationWhereUniqueInput!): Specialization
  deleteManySpecializations(where: SpecializationWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Permission {
  id: ID!
  name: String!
  key: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PermissionConnection {
  pageInfo: PageInfo!
  edges: [PermissionEdge]!
  aggregate: AggregatePermission!
}

input PermissionCreateInput {
  id: ID
  name: String!
  key: String!
}

input PermissionCreateManyInput {
  create: [PermissionCreateInput!]
  connect: [PermissionWhereUniqueInput!]
}

type PermissionEdge {
  node: Permission!
  cursor: String!
}

enum PermissionOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  key_ASC
  key_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PermissionPreviousValues {
  id: ID!
  name: String!
  key: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input PermissionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PermissionScalarWhereInput!]
  OR: [PermissionScalarWhereInput!]
  NOT: [PermissionScalarWhereInput!]
}

type PermissionSubscriptionPayload {
  mutation: MutationType!
  node: Permission
  updatedFields: [String!]
  previousValues: PermissionPreviousValues
}

input PermissionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PermissionWhereInput
  AND: [PermissionSubscriptionWhereInput!]
  OR: [PermissionSubscriptionWhereInput!]
  NOT: [PermissionSubscriptionWhereInput!]
}

input PermissionUpdateDataInput {
  name: String
  key: String
}

input PermissionUpdateInput {
  name: String
  key: String
}

input PermissionUpdateManyDataInput {
  name: String
  key: String
}

input PermissionUpdateManyInput {
  create: [PermissionCreateInput!]
  update: [PermissionUpdateWithWhereUniqueNestedInput!]
  upsert: [PermissionUpsertWithWhereUniqueNestedInput!]
  delete: [PermissionWhereUniqueInput!]
  connect: [PermissionWhereUniqueInput!]
  set: [PermissionWhereUniqueInput!]
  disconnect: [PermissionWhereUniqueInput!]
  deleteMany: [PermissionScalarWhereInput!]
  updateMany: [PermissionUpdateManyWithWhereNestedInput!]
}

input PermissionUpdateManyMutationInput {
  name: String
  key: String
}

input PermissionUpdateManyWithWhereNestedInput {
  where: PermissionScalarWhereInput!
  data: PermissionUpdateManyDataInput!
}

input PermissionUpdateWithWhereUniqueNestedInput {
  where: PermissionWhereUniqueInput!
  data: PermissionUpdateDataInput!
}

input PermissionUpsertWithWhereUniqueNestedInput {
  where: PermissionWhereUniqueInput!
  update: PermissionUpdateDataInput!
  create: PermissionCreateInput!
}

input PermissionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  key: String
  key_not: String
  key_in: [String!]
  key_not_in: [String!]
  key_lt: String
  key_lte: String
  key_gt: String
  key_gte: String
  key_contains: String
  key_not_contains: String
  key_starts_with: String
  key_not_starts_with: String
  key_ends_with: String
  key_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PermissionWhereInput!]
  OR: [PermissionWhereInput!]
  NOT: [PermissionWhereInput!]
}

input PermissionWhereUniqueInput {
  id: ID
  key: String
}

type Query {
  accountType(where: AccountTypeWhereUniqueInput!): AccountType
  accountTypes(where: AccountTypeWhereInput, orderBy: AccountTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AccountType]!
  accountTypesConnection(where: AccountTypeWhereInput, orderBy: AccountTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AccountTypeConnection!
  chatRoom(where: ChatRoomWhereUniqueInput!): ChatRoom
  chatRooms(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom]!
  chatRoomsConnection(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatRoomConnection!
  messageContent(where: MessageContentWhereUniqueInput!): MessageContent
  messageContents(where: MessageContentWhereInput, orderBy: MessageContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [MessageContent]!
  messageContentsConnection(where: MessageContentWhereInput, orderBy: MessageContentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageContentConnection!
  permission(where: PermissionWhereUniqueInput!): Permission
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission]!
  permissionsConnection(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PermissionConnection!
  specialization(where: SpecializationWhereUniqueInput!): Specialization
  specializations(where: SpecializationWhereInput, orderBy: SpecializationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Specialization]!
  specializationsConnection(where: SpecializationWhereInput, orderBy: SpecializationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SpecializationConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Specialization {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SpecializationConnection {
  pageInfo: PageInfo!
  edges: [SpecializationEdge]!
  aggregate: AggregateSpecialization!
}

input SpecializationCreateInput {
  id: ID
  name: String!
}

input SpecializationCreateOneInput {
  create: SpecializationCreateInput
  connect: SpecializationWhereUniqueInput
}

type SpecializationEdge {
  node: Specialization!
  cursor: String!
}

enum SpecializationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SpecializationPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SpecializationSubscriptionPayload {
  mutation: MutationType!
  node: Specialization
  updatedFields: [String!]
  previousValues: SpecializationPreviousValues
}

input SpecializationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SpecializationWhereInput
  AND: [SpecializationSubscriptionWhereInput!]
  OR: [SpecializationSubscriptionWhereInput!]
  NOT: [SpecializationSubscriptionWhereInput!]
}

input SpecializationUpdateDataInput {
  name: String
}

input SpecializationUpdateInput {
  name: String
}

input SpecializationUpdateManyMutationInput {
  name: String
}

input SpecializationUpdateOneInput {
  create: SpecializationCreateInput
  update: SpecializationUpdateDataInput
  upsert: SpecializationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: SpecializationWhereUniqueInput
}

input SpecializationUpsertNestedInput {
  update: SpecializationUpdateDataInput!
  create: SpecializationCreateInput!
}

input SpecializationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SpecializationWhereInput!]
  OR: [SpecializationWhereInput!]
  NOT: [SpecializationWhereInput!]
}

input SpecializationWhereUniqueInput {
  id: ID
}

type Subscription {
  accountType(where: AccountTypeSubscriptionWhereInput): AccountTypeSubscriptionPayload
  chatRoom(where: ChatRoomSubscriptionWhereInput): ChatRoomSubscriptionPayload
  messageContent(where: MessageContentSubscriptionWhereInput): MessageContentSubscriptionPayload
  permission(where: PermissionSubscriptionWhereInput): PermissionSubscriptionPayload
  specialization(where: SpecializationSubscriptionWhereInput): SpecializationSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  firebase_id: String!
  name: String!
  phone: String!
  gender: String!
  photoURL: String
  account_type: AccountType!
  verified: Boolean
  specialization: Specialization
  doctors(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  patients(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  chatRooms(where: ChatRoomWhereInput, orderBy: ChatRoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatRoom!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  firebase_id: String!
  name: String!
  phone: String!
  gender: String!
  photoURL: String
  account_type: AccountTypeCreateOneWithoutUsersInput!
  verified: Boolean
  specialization: SpecializationCreateOneInput
  doctors: UserCreateManyWithoutDoctorsInput
  patients: UserCreateManyWithoutPatientsInput
  chatRooms: ChatRoomCreateManyWithoutRecipientsInput
}

input UserCreateManyWithoutAccount_typeInput {
  create: [UserCreateWithoutAccount_typeInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutChatRoomsInput {
  create: [UserCreateWithoutChatRoomsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutDoctorsInput {
  create: [UserCreateWithoutDoctorsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutPatientsInput {
  create: [UserCreateWithoutPatientsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutAccount_typeInput {
  id: ID
  firebase_id: String!
  name: String!
  phone: String!
  gender: String!
  photoURL: String
  verified: Boolean
  specialization: SpecializationCreateOneInput
  doctors: UserCreateManyWithoutDoctorsInput
  patients: UserCreateManyWithoutPatientsInput
  chatRooms: ChatRoomCreateManyWithoutRecipientsInput
}

input UserCreateWithoutChatRoomsInput {
  id: ID
  firebase_id: String!
  name: String!
  phone: String!
  gender: String!
  photoURL: String
  account_type: AccountTypeCreateOneWithoutUsersInput!
  verified: Boolean
  specialization: SpecializationCreateOneInput
  doctors: UserCreateManyWithoutDoctorsInput
  patients: UserCreateManyWithoutPatientsInput
}

input UserCreateWithoutDoctorsInput {
  id: ID
  firebase_id: String!
  name: String!
  phone: String!
  gender: String!
  photoURL: String
  account_type: AccountTypeCreateOneWithoutUsersInput!
  verified: Boolean
  specialization: SpecializationCreateOneInput
  patients: UserCreateManyWithoutPatientsInput
  chatRooms: ChatRoomCreateManyWithoutRecipientsInput
}

input UserCreateWithoutPatientsInput {
  id: ID
  firebase_id: String!
  name: String!
  phone: String!
  gender: String!
  photoURL: String
  account_type: AccountTypeCreateOneWithoutUsersInput!
  verified: Boolean
  specialization: SpecializationCreateOneInput
  doctors: UserCreateManyWithoutDoctorsInput
  chatRooms: ChatRoomCreateManyWithoutRecipientsInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  firebase_id_ASC
  firebase_id_DESC
  name_ASC
  name_DESC
  phone_ASC
  phone_DESC
  gender_ASC
  gender_DESC
  photoURL_ASC
  photoURL_DESC
  verified_ASC
  verified_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  firebase_id: String!
  name: String!
  phone: String!
  gender: String!
  photoURL: String
  verified: Boolean
  createdAt: DateTime!
  updatedAt: DateTime!
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firebase_id: String
  firebase_id_not: String
  firebase_id_in: [String!]
  firebase_id_not_in: [String!]
  firebase_id_lt: String
  firebase_id_lte: String
  firebase_id_gt: String
  firebase_id_gte: String
  firebase_id_contains: String
  firebase_id_not_contains: String
  firebase_id_starts_with: String
  firebase_id_not_starts_with: String
  firebase_id_ends_with: String
  firebase_id_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  photoURL: String
  photoURL_not: String
  photoURL_in: [String!]
  photoURL_not_in: [String!]
  photoURL_lt: String
  photoURL_lte: String
  photoURL_gt: String
  photoURL_gte: String
  photoURL_contains: String
  photoURL_not_contains: String
  photoURL_starts_with: String
  photoURL_not_starts_with: String
  photoURL_ends_with: String
  photoURL_not_ends_with: String
  verified: Boolean
  verified_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  firebase_id: String
  name: String
  phone: String
  gender: String
  photoURL: String
  account_type: AccountTypeUpdateOneRequiredWithoutUsersInput
  verified: Boolean
  specialization: SpecializationUpdateOneInput
  doctors: UserUpdateManyWithoutDoctorsInput
  patients: UserUpdateManyWithoutPatientsInput
  chatRooms: ChatRoomUpdateManyWithoutRecipientsInput
}

input UserUpdateInput {
  firebase_id: String
  name: String
  phone: String
  gender: String
  photoURL: String
  account_type: AccountTypeUpdateOneRequiredWithoutUsersInput
  verified: Boolean
  specialization: SpecializationUpdateOneInput
  doctors: UserUpdateManyWithoutDoctorsInput
  patients: UserUpdateManyWithoutPatientsInput
  chatRooms: ChatRoomUpdateManyWithoutRecipientsInput
}

input UserUpdateManyDataInput {
  firebase_id: String
  name: String
  phone: String
  gender: String
  photoURL: String
  verified: Boolean
}

input UserUpdateManyMutationInput {
  firebase_id: String
  name: String
  phone: String
  gender: String
  photoURL: String
  verified: Boolean
}

input UserUpdateManyWithoutAccount_typeInput {
  create: [UserCreateWithoutAccount_typeInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutAccount_typeInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutAccount_typeInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutChatRoomsInput {
  create: [UserCreateWithoutChatRoomsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutChatRoomsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutChatRoomsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutDoctorsInput {
  create: [UserCreateWithoutDoctorsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutDoctorsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutDoctorsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutPatientsInput {
  create: [UserCreateWithoutPatientsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutPatientsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutPatientsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutAccount_typeDataInput {
  firebase_id: String
  name: String
  phone: String
  gender: String
  photoURL: String
  verified: Boolean
  specialization: SpecializationUpdateOneInput
  doctors: UserUpdateManyWithoutDoctorsInput
  patients: UserUpdateManyWithoutPatientsInput
  chatRooms: ChatRoomUpdateManyWithoutRecipientsInput
}

input UserUpdateWithoutChatRoomsDataInput {
  firebase_id: String
  name: String
  phone: String
  gender: String
  photoURL: String
  account_type: AccountTypeUpdateOneRequiredWithoutUsersInput
  verified: Boolean
  specialization: SpecializationUpdateOneInput
  doctors: UserUpdateManyWithoutDoctorsInput
  patients: UserUpdateManyWithoutPatientsInput
}

input UserUpdateWithoutDoctorsDataInput {
  firebase_id: String
  name: String
  phone: String
  gender: String
  photoURL: String
  account_type: AccountTypeUpdateOneRequiredWithoutUsersInput
  verified: Boolean
  specialization: SpecializationUpdateOneInput
  patients: UserUpdateManyWithoutPatientsInput
  chatRooms: ChatRoomUpdateManyWithoutRecipientsInput
}

input UserUpdateWithoutPatientsDataInput {
  firebase_id: String
  name: String
  phone: String
  gender: String
  photoURL: String
  account_type: AccountTypeUpdateOneRequiredWithoutUsersInput
  verified: Boolean
  specialization: SpecializationUpdateOneInput
  doctors: UserUpdateManyWithoutDoctorsInput
  chatRooms: ChatRoomUpdateManyWithoutRecipientsInput
}

input UserUpdateWithWhereUniqueWithoutAccount_typeInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutAccount_typeDataInput!
}

input UserUpdateWithWhereUniqueWithoutChatRoomsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutChatRoomsDataInput!
}

input UserUpdateWithWhereUniqueWithoutDoctorsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutDoctorsDataInput!
}

input UserUpdateWithWhereUniqueWithoutPatientsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutPatientsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutAccount_typeInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutAccount_typeDataInput!
  create: UserCreateWithoutAccount_typeInput!
}

input UserUpsertWithWhereUniqueWithoutChatRoomsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutChatRoomsDataInput!
  create: UserCreateWithoutChatRoomsInput!
}

input UserUpsertWithWhereUniqueWithoutDoctorsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutDoctorsDataInput!
  create: UserCreateWithoutDoctorsInput!
}

input UserUpsertWithWhereUniqueWithoutPatientsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutPatientsDataInput!
  create: UserCreateWithoutPatientsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  firebase_id: String
  firebase_id_not: String
  firebase_id_in: [String!]
  firebase_id_not_in: [String!]
  firebase_id_lt: String
  firebase_id_lte: String
  firebase_id_gt: String
  firebase_id_gte: String
  firebase_id_contains: String
  firebase_id_not_contains: String
  firebase_id_starts_with: String
  firebase_id_not_starts_with: String
  firebase_id_ends_with: String
  firebase_id_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  photoURL: String
  photoURL_not: String
  photoURL_in: [String!]
  photoURL_not_in: [String!]
  photoURL_lt: String
  photoURL_lte: String
  photoURL_gt: String
  photoURL_gte: String
  photoURL_contains: String
  photoURL_not_contains: String
  photoURL_starts_with: String
  photoURL_not_starts_with: String
  photoURL_ends_with: String
  photoURL_not_ends_with: String
  account_type: AccountTypeWhereInput
  verified: Boolean
  verified_not: Boolean
  specialization: SpecializationWhereInput
  doctors_every: UserWhereInput
  doctors_some: UserWhereInput
  doctors_none: UserWhereInput
  patients_every: UserWhereInput
  patients_some: UserWhereInput
  patients_none: UserWhereInput
  chatRooms_every: ChatRoomWhereInput
  chatRooms_some: ChatRoomWhereInput
  chatRooms_none: ChatRoomWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  firebase_id: String
}
`
      }
    